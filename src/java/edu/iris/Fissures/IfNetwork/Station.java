// **********************************************************************
//
// Generated by the ORBacus IDL to Java Translator
//
// Copyright (c) 2000
// Object Oriented Concepts, Inc.
// Billerica, MA, USA
//
// All Rights Reserved
//
// **********************************************************************
// Version: 4.0.5
package edu.iris.Fissures.IfNetwork;

import java.lang.ref.WeakReference;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import edu.iris.Fissures.Location;
import edu.iris.Fissures.Time;
import edu.iris.Fissures.TimeRange;

//
// IDL:iris.edu/Fissures/IfNetwork/Station:1.0
//
/**
 * Represents a seismic recording station. Following the SEED convention,
 * multiple sensors within a 1 km cube can be considered the same station.
 */
public abstract class Station implements org.omg.CORBA.portable.StreamableValue {

    //
    // IDL:iris.edu/Fissures/IfNetwork/Station/id:1.0
    //
    /** Uniquely identifies this station. */
    protected StationId id;

    //
    // IDL:iris.edu/Fissures/IfNetwork/Station/name:1.0
    //
    /**
     * A name for this station. The form of this is not specified, but it should
     * be usable as a display for a person.
     */
    protected String name;

    //
    // IDL:iris.edu/Fissures/IfNetwork/Station/my_location:1.0
    //
    /**
     * The location of the station. Note that following the SEED conventions on
     * station, the actual location of the recording instruments may be slightly
     * offset from this location, up to 1 kilometer.
     */
    private edu.iris.Fissures.Location my_location;

    //
    // IDL:iris.edu/Fissures/IfNetwork/Station/effective_time:1.0
    //
    /**
     * The effective time of the stations. The begin should be at or before any
     * data is recorded. If the station is still active, the end time should be
     * TIME_UNKNOWN as defined in IfConstants.idl.
     */
    private edu.iris.Fissures.TimeRange effective_time;

    //
    // IDL:iris.edu/Fissures/IfNetwork/Station/operator:1.0
    //
    /**
     * The operator of the station. This the form of this is not specified but
     * it should be usable as a display for a person.
     */
    protected String operator;

    //
    // IDL:iris.edu/Fissures/IfNetwork/Station/description:1.0
    //
    /**
     * An additional description of the station, if needed. The form is not
     * specified, but it should be usable as a display for a person.
     */
    protected String description;

    //
    // IDL:iris.edu/Fissures/IfNetwork/Station/comment:1.0
    //
    /** An a additional comment about the station, with unspecified form. */
    protected String comment;

    //
    // IDL:iris.edu/Fissures/IfNetwork/Station/my_network:1.0
    //
    /** The network attributes of the network that this station belongs. */
    private NetworkAttr my_network;

    //
    // IDL:iris.edu/Fissures/IfNetwork/Station/get_id:1.0
    //
    /** Accesses the id of this station. */
    public abstract StationId get_id();

    //
    // IDL:iris.edu/Fissures/IfNetwork/Station/get_code:1.0
    //
    /**
     * Accesses the station code. This is equivalent to get_id().station_code
     */
    public abstract String get_code();

    private static String[] _OB_truncatableIds_ = {StationHelper.id()};

    public String[] _truncatable_ids() {
        return _OB_truncatableIds_;
    }

    public void _read(org.omg.CORBA.portable.InputStream in) {
        id = StationIdHelper.read(in);
        name = in.read_string();
        setLocation(edu.iris.Fissures.LocationHelper.read(in));
        setEffectiveTime(edu.iris.Fissures.TimeRangeHelper.read(in));
        operator = in.read_string();
        description = in.read_string();
        comment = in.read_string();
        setNetworkAttr(NetworkAttrHelper.read(in));
    }

    public void _write(org.omg.CORBA.portable.OutputStream out) {
        StationIdHelper.write(out, id);
        out.write_string(name);
        edu.iris.Fissures.LocationHelper.write(out, getLocation());
        edu.iris.Fissures.TimeRangeHelper.write(out, getEffectiveTime());
        out.write_string(operator);
        out.write_string(description);
        out.write_string(comment);
        NetworkAttrHelper.write(out, getNetworkAttr());
    }

    public org.omg.CORBA.TypeCode _type() {
        return StationHelper.type();
    }

    // added manually
    public String getName() {
        return name;
    }

    public Location getLocation() {
        return my_location;
    }

    public TimeRange getEffectiveTime() {
        return effective_time;
    }

    public String getOperator() {
        return operator;
    }

    public String getDescription() {
        return description;
    }

    public String getComment() {
        return comment;
    }

    public NetworkAttr getNetworkAttr() {
        return my_network;
    }

    public StationId getId() {
        if(id != null && id.network_id == null && getNetworkAttr() != null) {
            id.network_id = getNetworkAttr().getId();
        }
        return id;
    }

    public static void intern(StationId id) {
        NetworkAttr.intern(id.network_id);
        id.station_code = id.station_code.intern();
        id.begin_time = NetworkAttr.intern(id.begin_time);
    }

    public static Station intern(Station station) {
        synchronized(knownStations) {
            String key = station.getNetworkAttr().getId().network_code
                    + station.getNetworkAttr().getId().begin_time.date_time
                    + ":" + station.getId().station_code+station.getId().begin_time.date_time;
            
            Station interned = null;
            if(knownStations.containsKey(key)) {
                // don't return here, still have to check for null due to weak reference
                interned = knownStations.get(key).get();
            }
            if(interned == null) {
                knownStations.put(key, new WeakReference<Station>(station));
                intern(station.getId());
                station.setNetworkAttr(NetworkAttr.intern(station.getNetworkAttr()));
                station.getId().network_id = station.getNetworkAttr().getId();
                station.setName(station.getName().intern());
                station.setDescription(station.getDescription().intern());
                station.setOperator(station.getOperator().intern());
                station.setComment(station.getComment().intern());
                station.setEffectiveTime(NetworkAttr.intern(station.getEffectiveTime()));
                return station;
            }
            return interned;
        }
    }

    private static final org.apache.log4j.Logger logger = org.apache.log4j.Logger.getLogger(Station.class);

    private static Map<String, WeakReference<Station>> knownStations = Collections.synchronizedMap(new HashMap<String, WeakReference<Station>>());

    protected void setId(StationId id) {
        this.id = id;
        if(id.network_id != null) {
            if(getNetworkAttr() != null) {
                getNetworkAttr().setId(id.network_id);
            }
        } else {
            if(getNetworkAttr() != null) {
                id.network_id = getNetworkAttr().get_id();
            }
        }
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setLocation(Location loc) {
        this.my_location = loc;
    }

    protected void setEffectiveTime(TimeRange eff) {
        this.effective_time = eff;
    }

    public void setOperator(String operator) {
        this.operator = operator;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    public void setNetworkAttr(NetworkAttr attr) {
        this.my_network = attr;
        if(my_network != null) {
            if(id != null && my_network.get_id() != null) {
                id.network_id = my_network.get_id();
            }
        }
    }
    public Time getBeginTime() {
        return get_id().begin_time;
    }
    
    public void setBeginTime(Time beginTime) {
        if (getEffectiveTime() == null) {
            setEffectiveTime(new TimeRange());
        }
        this.getEffectiveTime().start_time = beginTime;
        get_id().begin_time = beginTime;
    }
    
    public Time getEndTime() {
        return getEffectiveTime().end_time;
    }
    
    public void setEndTime(Time endTime) {
        if (getEffectiveTime() == null) {
            setEffectiveTime(new TimeRange());
            this.getEffectiveTime().start_time = get_id().begin_time;
        }
        this.getEffectiveTime().end_time = endTime;
    }
}
