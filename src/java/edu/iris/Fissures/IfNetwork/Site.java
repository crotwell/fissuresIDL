// **********************************************************************
//
// Generated by the ORBacus IDL to Java Translator
//
// Copyright (c) 2000
// Object Oriented Concepts, Inc.
// Billerica, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.0.5

package edu.iris.Fissures.IfNetwork;

import java.lang.ref.WeakReference;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import edu.iris.Fissures.Location;
import edu.iris.Fissures.Time;
import edu.iris.Fissures.TimeRange;

//
// IDL:iris.edu/Fissures/IfNetwork/Site:1.0
//
/** Represents a seismic recording site. This is roughly equivalent to
 *  the location identifier in SEED. Channels from a single site should
 *  come frm the same location, but the converse is not required. */

public abstract class Site implements org.omg.CORBA.portable.StreamableValue
{
    //
    // IDL:iris.edu/Fissures/IfNetwork/Site/id:1.0
    //
    /** The unique identifier of this site. */

    protected SiteId id;

    //
    // IDL:iris.edu/Fissures/IfNetwork/Site/my_location:1.0
    //
    /** The location of this site. */

    protected edu.iris.Fissures.Location my_location;

    //
    // IDL:iris.edu/Fissures/IfNetwork/Site/effective_time:1.0
    //
    /** The effective time of this site. The begin should be at or before
     *  any data was recorded by any channel within this site. If the site is
     *  still operating, then the end should be TIME_UNKNOWN as defined
     *  in IfConstants.idl. */

    protected edu.iris.Fissures.TimeRange effective_time;

    //
    // IDL:iris.edu/Fissures/IfNetwork/Site/my_station:1.0
    //
    /** The station to which this site belongs. */

    private Station my_station;

    //
    // IDL:iris.edu/Fissures/IfNetwork/Site/comment:1.0
    //
    /** Any additional comment for this site. The form of this is not 
     *specified, but it should be usable as a display for a person. */

    protected String comment;

    //
    // IDL:iris.edu/Fissures/IfNetwork/Site/get_id:1.0
    //
    /** An accessor method for the private id. */

    public abstract SiteId
    get_id();

    //
    // IDL:iris.edu/Fissures/IfNetwork/Site/get_code:1.0
    //
    /** Accesses the site code. This is equivalent to the SEED location 
     *  identifier and to get_id().site_code. */

    public abstract String
    get_code();

    private static String[] _OB_truncatableIds_ =
    {
        SiteHelper.id()
    };

    public String[]
    _truncatable_ids()
    {
        return _OB_truncatableIds_;
    }

    public void
    _read(org.omg.CORBA.portable.InputStream in)
    {
        id = SiteIdHelper.read(in);
        my_location = edu.iris.Fissures.LocationHelper.read(in);
        effective_time = edu.iris.Fissures.TimeRangeHelper.read(in);
        setStation(StationHelper.read(in));
        comment = in.read_string();
    }

    public void
    _write(org.omg.CORBA.portable.OutputStream out)
    {
        SiteIdHelper.write(out, id);
        edu.iris.Fissures.LocationHelper.write(out, my_location);
        edu.iris.Fissures.TimeRangeHelper.write(out, effective_time);
        StationHelper.write(out, getStation());
        out.write_string(comment);
    }

    public org.omg.CORBA.TypeCode
    _type()
    {
        return SiteHelper.type();
    }
    
    // add manually


    public SiteId getId() {
        if (id != null && id.network_id == null && getStation() != null && getStation().getNetworkAttr() != null) {
            id.network_id = getStation().getNetworkAttr().getId();
        }
        return id;
    }
    
    public Location getLocation() {return my_location; }

    public TimeRange getEffectiveTime() {return effective_time; }

    public Station getStation() { return my_station; }

    public String getComment() { return comment; }


    public static void intern(SiteId id) {
        NetworkAttr.intern(id.network_id);
        id.station_code = id.station_code.intern();
        id.site_code = id.site_code.intern();
        id.begin_time = NetworkAttr.intern(id.begin_time);
    }

    public static Site intern(Site site) {
        synchronized(knownSites) {
            String key = site.getStation().getNetworkAttr().getId().network_code
            + site.getStation().getNetworkAttr().getId().begin_time.date_time
            + ":" + site.getStation().getId().station_code
            +":"+site.getId().site_code
            + site.getId().begin_time.date_time;
            Site interned = null;
            if(knownSites.containsKey(key)) {
                // don't return here, still must check for null due to weak reference
                interned = knownSites.get(key).get();
            }
            if(interned == null) {
                knownSites.put(key, new WeakReference<Site>(site));
                intern(site.get_id());
                site.comment = site.comment.intern();
                site.setStation(Station.intern(site.getStation()));
                site.getId().network_id = site.getStation().getNetworkAttr().getId();
                site.effective_time = NetworkAttr.intern(site.effective_time);
                return site;
            }
            return interned;
        }
    }

    private static Map<String, WeakReference<Site>> knownSites = Collections.synchronizedMap(new HashMap<String, WeakReference<Site>>());
    
    // hibernate
    protected void setId(SiteId s) {
        this.id = s;
    }
    
    protected void setLocation(Location loc) {
        this.my_location = loc;
    }
    protected void setEffectiveTime(TimeRange effective_time) {
        this.effective_time = effective_time;
    }
    
    public void setStation(Station my_station) {
        this.my_station = my_station;
    }
    protected void setComment(String comment) {
        this.comment = comment;
    }

    public Time getBeginTime() {
        return get_id().begin_time;
    }
    
    protected void setBeginTime(Time beginTime) {
        if (effective_time == null) {
            effective_time = new TimeRange();
        }
        this.effective_time.start_time = beginTime;
        get_id().begin_time = beginTime;
    }
    
    public Time getEndTime() {
        return effective_time.end_time;
    }
    
    protected void setEndTime(Time endTime) {
        if (effective_time == null) {
            effective_time = new TimeRange();
        }
        this.effective_time.end_time = endTime;
        this.effective_time.start_time = get_id().begin_time;
    }
}
