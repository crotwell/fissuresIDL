// **********************************************************************
//
// Generated by the ORBacus IDL to Java Translator
//
// Copyright (c) 2000
// Object Oriented Concepts, Inc.
// Billerica, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.0.5

package edu.iris.Fissures.IfRealTimeCollector;

//
// IDL:iris.edu/Fissures/IfRealTimeCollector/RealTimeCollector:1.0
//
/**
 * The real time collector is an interface to accepts raw data from
 * data acquisition system. Implementation of this interface would
 * act as either store and forward proxies or seismogram creation
 * system.
 * Seismogram creation implementation would connect to
 * one or more Seismogram factories and create new seismogram then
 * append data to them. These implementation would have the
 * knowledge of how to partition raw data into seperate seismograms
 **/

public interface RealTimeCollectorOperations
{
    //
    // IDL:iris.edu/Fissures/IfRealTimeCollector/RealTimeCollector/configure:1.0
    //
    /***/

    void
    configure(CollectorConfiguration[] a_configuration);

    //
    // IDL:iris.edu/Fissures/IfRealTimeCollector/RealTimeCollector/add_data:1.0
    //
    /** Adds data to the collector. If any exception occurs, the client should
     *assume that no data was successfully sent. It should attempt to 
     *correct the errors before resending the data.
     **/

    void
    add_data(DataChunk[] data)
        throws UnknownChannels,
               ChunkOutOfOrder;

    //
    // IDL:iris.edu/Fissures/IfRealTimeCollector/RealTimeCollector/reset_sequence:1.0
    //
    /**Collector would reset his sequence counter and most likely close the old
     *seismogram and start a new one.
     *Sequences must be the same length. */

    void
    reset_sequence(edu.iris.Fissures.IfNetwork.ChannelId[] channels,
                   int[] next_valid)
        throws UnknownChannels;

    //
    // IDL:iris.edu/Fissures/IfRealTimeCollector/RealTimeCollector/get_collector:1.0
    //
    /** Allows the DAS the send cached data seperate from real time data. 
     *This allows most recent data to be processed first and older data 
     *to be send through a seperate collector. It is the decision of 
     *the DAS as to which collector gets the real time
     *data and which gets the older data.
     **/

    RealTimeCollector
    get_collector()
        throws edu.iris.Fissures.NotImplemented;

    //
    // IDL:iris.edu/Fissures/IfRealTimeCollector/RealTimeCollector/destroy:1.0
    //
    /** Once all history data is send the Collector is useless. No more 
     *data will be sent through it. It can be destroyed.
     **/

    void
    destroy();
}
